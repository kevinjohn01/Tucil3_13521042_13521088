{"ast":null,"code":"function UCS(startNode, endNode, weight) {\n  //weight -> float[][]\n  const queue = new PriorityQueue();\n  const visited = new Set();\n  const distance = Array(weight.length).fill(Infinity);\n  const path = Array(weight.length).fill(null);\n  distance[startNode] = 0;\n  queue.enqueue(startNode, 0);\n  while (!queue.isEmpty()) {\n    const currentNode = queue.dequeue();\n    if (currentNode === endNode) {\n      return getPath(path, startNode, endNode);\n    }\n    if (visited.has(currentNode)) {\n      continue;\n    }\n    visited.add(currentNode);\n    for (let neighbor = 0; neighbor < weight.length; neighbor++) {\n      if (weight[currentNode][neighbor] === 0) {\n        continue;\n      }\n      const neighborDistance = distance[currentNode] + weight[currentNode][neighbor];\n      if (neighborDistance < distance[neighbor]) {\n        distance[neighbor] = neighborDistance;\n        path[neighbor] = currentNode;\n        queue.enqueue(neighbor, neighborDistance);\n      }\n    }\n  }\n  return null;\n}\n_c = UCS;\nfunction getPath(path, startNode, endNode) {\n  const result = [];\n  let currentNode = endNode;\n  while (currentNode !== startNode) {\n    result.unshift(currentNode);\n    currentNode = path[currentNode];\n  }\n  result.unshift(startNode);\n  return result;\n}\nclass PriorityQueue {\n  constructor() {\n    this.items = [];\n  }\n  enqueue(item, priority) {\n    this.items.push({\n      item,\n      priority\n    });\n    this.items.sort((a, b) => a.priority - b.priority);\n  }\n  dequeue() {\n    return this.items.shift().item;\n  }\n  isEmpty() {\n    return this.items.length === 0;\n  }\n}\nexport default UCS;\nvar _c;\n$RefreshReg$(_c, \"UCS\");","map":{"version":3,"names":["UCS","startNode","endNode","weight","queue","PriorityQueue","visited","Set","distance","Array","length","fill","Infinity","path","enqueue","isEmpty","currentNode","dequeue","getPath","has","add","neighbor","neighborDistance","_c","result","unshift","constructor","items","item","priority","push","sort","a","b","shift","$RefreshReg$"],"sources":["/Users/putinabillaaidira/Downloads/KULIAH/Semester 4/STIMA/Tucil3_13521042_13521088/src/app/src/algorithm/UCS.js"],"sourcesContent":["function UCS(startNode, endNode, weight){ //weight -> float[][]\n    const queue = new PriorityQueue();\n    const visited = new Set();\n    const distance = Array(weight.length).fill(Infinity);\n    const path = Array(weight.length).fill(null);\n    \n    distance[startNode] = 0;\n    queue.enqueue(startNode, 0);\n    \n    while (!queue.isEmpty()) {\n      const currentNode = queue.dequeue();\n      if (currentNode === endNode) {\n        return getPath(path, startNode, endNode);\n      }\n      if (visited.has(currentNode)) {\n        continue;\n      }\n      visited.add(currentNode);\n      \n      for (let neighbor = 0; neighbor < weight.length; neighbor++) {\n        if (weight[currentNode][neighbor] === 0) {\n          continue;\n        }\n        const neighborDistance = distance[currentNode] + weight[currentNode][neighbor];\n        if (neighborDistance < distance[neighbor]) {\n          distance[neighbor] = neighborDistance;\n          path[neighbor] = currentNode;\n          queue.enqueue(neighbor, neighborDistance);\n        }\n      }\n    }\n    \n    return null;\n}\n  \nfunction getPath(path, startNode, endNode) {\n    const result = [];\n    let currentNode = endNode;\n    while (currentNode !== startNode) {\n      result.unshift(currentNode);\n      currentNode = path[currentNode];\n    }\n    result.unshift(startNode);\n    return result;\n}\n  \nclass PriorityQueue {\n    constructor() {\n      this.items = [];\n    }\n  \n    enqueue(item, priority) {\n      this.items.push({ item, priority });\n      this.items.sort((a, b) => a.priority - b.priority);\n    }\n  \n    dequeue() {\n      return this.items.shift().item;\n    }\n  \n    isEmpty() {\n      return this.items.length === 0;\n    }\n}\nexport default UCS;"],"mappings":"AAAA,SAASA,GAAGA,CAACC,SAAS,EAAEC,OAAO,EAAEC,MAAM,EAAC;EAAE;EACtC,MAAMC,KAAK,GAAG,IAAIC,aAAa,EAAE;EACjC,MAAMC,OAAO,GAAG,IAAIC,GAAG,EAAE;EACzB,MAAMC,QAAQ,GAAGC,KAAK,CAACN,MAAM,CAACO,MAAM,CAAC,CAACC,IAAI,CAACC,QAAQ,CAAC;EACpD,MAAMC,IAAI,GAAGJ,KAAK,CAACN,MAAM,CAACO,MAAM,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC;EAE5CH,QAAQ,CAACP,SAAS,CAAC,GAAG,CAAC;EACvBG,KAAK,CAACU,OAAO,CAACb,SAAS,EAAE,CAAC,CAAC;EAE3B,OAAO,CAACG,KAAK,CAACW,OAAO,EAAE,EAAE;IACvB,MAAMC,WAAW,GAAGZ,KAAK,CAACa,OAAO,EAAE;IACnC,IAAID,WAAW,KAAKd,OAAO,EAAE;MAC3B,OAAOgB,OAAO,CAACL,IAAI,EAAEZ,SAAS,EAAEC,OAAO,CAAC;IAC1C;IACA,IAAII,OAAO,CAACa,GAAG,CAACH,WAAW,CAAC,EAAE;MAC5B;IACF;IACAV,OAAO,CAACc,GAAG,CAACJ,WAAW,CAAC;IAExB,KAAK,IAAIK,QAAQ,GAAG,CAAC,EAAEA,QAAQ,GAAGlB,MAAM,CAACO,MAAM,EAAEW,QAAQ,EAAE,EAAE;MAC3D,IAAIlB,MAAM,CAACa,WAAW,CAAC,CAACK,QAAQ,CAAC,KAAK,CAAC,EAAE;QACvC;MACF;MACA,MAAMC,gBAAgB,GAAGd,QAAQ,CAACQ,WAAW,CAAC,GAAGb,MAAM,CAACa,WAAW,CAAC,CAACK,QAAQ,CAAC;MAC9E,IAAIC,gBAAgB,GAAGd,QAAQ,CAACa,QAAQ,CAAC,EAAE;QACzCb,QAAQ,CAACa,QAAQ,CAAC,GAAGC,gBAAgB;QACrCT,IAAI,CAACQ,QAAQ,CAAC,GAAGL,WAAW;QAC5BZ,KAAK,CAACU,OAAO,CAACO,QAAQ,EAAEC,gBAAgB,CAAC;MAC3C;IACF;EACF;EAEA,OAAO,IAAI;AACf;AAACC,EAAA,GAjCQvB,GAAG;AAmCZ,SAASkB,OAAOA,CAACL,IAAI,EAAEZ,SAAS,EAAEC,OAAO,EAAE;EACvC,MAAMsB,MAAM,GAAG,EAAE;EACjB,IAAIR,WAAW,GAAGd,OAAO;EACzB,OAAOc,WAAW,KAAKf,SAAS,EAAE;IAChCuB,MAAM,CAACC,OAAO,CAACT,WAAW,CAAC;IAC3BA,WAAW,GAAGH,IAAI,CAACG,WAAW,CAAC;EACjC;EACAQ,MAAM,CAACC,OAAO,CAACxB,SAAS,CAAC;EACzB,OAAOuB,MAAM;AACjB;AAEA,MAAMnB,aAAa,CAAC;EAChBqB,WAAWA,CAAA,EAAG;IACZ,IAAI,CAACC,KAAK,GAAG,EAAE;EACjB;EAEAb,OAAOA,CAACc,IAAI,EAAEC,QAAQ,EAAE;IACtB,IAAI,CAACF,KAAK,CAACG,IAAI,CAAC;MAAEF,IAAI;MAAEC;IAAS,CAAC,CAAC;IACnC,IAAI,CAACF,KAAK,CAACI,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAACH,QAAQ,GAAGI,CAAC,CAACJ,QAAQ,CAAC;EACpD;EAEAZ,OAAOA,CAAA,EAAG;IACR,OAAO,IAAI,CAACU,KAAK,CAACO,KAAK,EAAE,CAACN,IAAI;EAChC;EAEAb,OAAOA,CAAA,EAAG;IACR,OAAO,IAAI,CAACY,KAAK,CAACjB,MAAM,KAAK,CAAC;EAChC;AACJ;AACA,eAAeV,GAAG;AAAC,IAAAuB,EAAA;AAAAY,YAAA,CAAAZ,EAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}