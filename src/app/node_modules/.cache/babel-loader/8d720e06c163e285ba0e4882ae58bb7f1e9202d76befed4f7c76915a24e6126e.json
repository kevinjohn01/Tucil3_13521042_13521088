{"ast":null,"code":"function AStar(startNode, endNode, weight, arrayOfCoordinat) {\n  //weight -> int[][]\n  const queue = new PriorityQueue();\n  const visited = new Set();\n  const distance = Array(weight.length).fill(Infinity);\n  const path = Array(weight.length).fill(null);\n  distance[startNode] = 0;\n  queue.enqueue(startNode, heuristic(startNode, endNode, arrayOfCoordinat)); //arrayOfCoordinat berisi kelas koordinat, atribut x,y\n\n  while (!queue.isEmpty()) {\n    const currentNode = queue.dequeue();\n    if (currentNode === endNode) {\n      return getPath(path, startNode, endNode);\n    }\n    if (visited.has(currentNode)) {\n      continue;\n    }\n    visited.add(currentNode);\n    for (let neighbor = 0; neighbor < weight.length; neighbor++) {\n      if (weight[currentNode][neighbor] === 0) {\n        continue;\n      }\n      const neighborDistance = distance[currentNode] + weight[currentNode][neighbor];\n      if (neighborDistance < distance[neighbor]) {\n        distance[neighbor] = neighborDistance;\n        path[neighbor] = currentNode;\n        queue.enqueue(neighbor, neighborDistance + heuristic(neighbor, endNode, arrayOfCoordinat));\n      }\n    }\n  }\n  return null;\n}\n_c = AStar;\nfunction getPath(path, startNode, endNode) {\n  const result = [];\n  let currentNode = endNode;\n  while (currentNode !== startNode) {\n    result.unshift(currentNode);\n    currentNode = path[currentNode];\n  }\n  result.unshift(startNode);\n  return result;\n}\nfunction heuristic(currNode, endNode, arrayOfCoordinat) {\n  let currX = arrayOfCoordinat[currNode][0];\n  let currY = arrayOfCoordinat[currNode][1];\n  let endX = arrayOfCoordinat[endNode][0];\n  let endY = arrayOfCoordinat[endNode][1];\n  return ((currX - endX) ** 2 + (currY - endY) ** 2) ** 0.5;\n}\nclass PriorityQueue {\n  constructor() {\n    this.items = [];\n  }\n  enqueue(item, priority) {\n    this.items.push({\n      item,\n      priority\n    });\n    this.items.sort((a, b) => a.priority - b.priority);\n  }\n  dequeue() {\n    return this.items.shift().item;\n  }\n  isEmpty() {\n    return this.items.length === 0;\n  }\n}\nexport default AStar;\nvar _c;\n$RefreshReg$(_c, \"AStar\");","map":{"version":3,"names":["AStar","startNode","endNode","weight","arrayOfCoordinat","queue","PriorityQueue","visited","Set","distance","Array","length","fill","Infinity","path","enqueue","heuristic","isEmpty","currentNode","dequeue","getPath","has","add","neighbor","neighborDistance","_c","result","unshift","currNode","currX","currY","endX","endY","constructor","items","item","priority","push","sort","a","b","shift","$RefreshReg$"],"sources":["/Users/putinabillaaidira/Downloads/KULIAH/Semester 4/STIMA/Tucil3_13521042_13521088/src/app/src/algorithm/AStar.js"],"sourcesContent":["function AStar(startNode, endNode, weight,arrayOfCoordinat){ //weight -> int[][]\n    const queue = new PriorityQueue();\n    const visited = new Set();\n    const distance = Array(weight.length).fill(Infinity);\n    const path = Array(weight.length).fill(null);\n    \n    distance[startNode] = 0;\n    queue.enqueue(startNode, heuristic(startNode,endNode,arrayOfCoordinat)); //arrayOfCoordinat berisi kelas koordinat, atribut x,y\n    \n    while (!queue.isEmpty()) {\n      const currentNode = queue.dequeue();\n      if (currentNode === endNode) {\n        return getPath(path, startNode, endNode);\n      }\n      if (visited.has(currentNode)) {\n        continue;\n      }\n      visited.add(currentNode);\n      \n      for (let neighbor = 0; neighbor < weight.length; neighbor++) {\n        if (weight[currentNode][neighbor] === 0) {\n          continue;\n        }\n        const neighborDistance = distance[currentNode] + weight[currentNode][neighbor];\n        if (neighborDistance < distance[neighbor]) {\n          distance[neighbor] = neighborDistance;\n          path[neighbor] = currentNode;\n          queue.enqueue(neighbor, neighborDistance + heuristic(neighbor,endNode,arrayOfCoordinat));\n        }\n      }\n    }\n    \n    return null;\n}\n  \nfunction getPath(path, startNode, endNode) {\n    const result = [];\n    let currentNode = endNode;\n    while (currentNode !== startNode) {\n      result.unshift(currentNode);\n      currentNode = path[currentNode];\n    }\n    result.unshift(startNode);\n    return result;\n}\n\nfunction heuristic(currNode,endNode,arrayOfCoordinat) {\n    let currX = arrayOfCoordinat[currNode][0];\n    let currY = arrayOfCoordinat[currNode][1];\n    let endX = arrayOfCoordinat[endNode][0];\n    let endY = arrayOfCoordinat[endNode][1];\n\n    return ((currX-endX)**2 + (currY-endY)**2)**(0.5);\n}\n  \nclass PriorityQueue {\n    constructor() {\n      this.items = [];\n    }\n  \n    enqueue(item, priority) {\n      this.items.push({ item, priority });\n      this.items.sort((a, b) => a.priority - b.priority);\n    }\n  \n    dequeue() {\n      return this.items.shift().item;\n    }\n  \n    isEmpty() {\n      return this.items.length === 0;\n    }\n}\nexport default AStar;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}